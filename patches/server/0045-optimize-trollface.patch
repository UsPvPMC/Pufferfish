From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Pyr <pyrmcserver@gmail.com>
Date: Sat, 4 Mar 2023 22:46:19 +0000
Subject: [PATCH] optimize :trollface:


diff --git a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
index a08cde4eefe879adcee7c4118bc38f98c5097ed0..a46b524076f7e8f5cd304e378b0cb86e1ec046f6 100644
--- a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
+++ b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
@@ -516,7 +516,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
      */
     public static void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
                                     final RegionFileType type) {
-        RegionFileIOThread.scheduleSave(world, chunkX, chunkZ, data, type, PrioritisedExecutor.Priority.NORMAL);
+        // RegionFileIOThread.scheduleSave(world, chunkX, chunkZ, data, type, PrioritisedExecutor.Priority.NORMAL);
     }
 
     /**
@@ -543,8 +543,8 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
      */
     public static void scheduleSave(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
                                     final RegionFileType type, final PrioritisedExecutor.Priority priority) {
-        final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
-        thread.scheduleSaveInternal(world, chunkX, chunkZ, data, type, priority);
+        // final RegionFileIOThread thread = RegionFileIOThread.selectThread(world, chunkX, chunkZ, type);
+        // thread.scheduleSaveInternal(world, chunkX, chunkZ, data, type, priority);
     }
 
     void scheduleSaveInternal(final ServerLevel world, final int chunkX, final int chunkZ, final CompoundTag data,
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 33a5e900c2cab99c311fa5f5b71a609cf8f802cb..b859f0691a4fabea574aa0c4f1b05a0abad1d4f9 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -14,6 +14,7 @@ import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.longs.LongIterator;
+
 import java.awt.image.BufferedImage;
 import java.io.BufferedWriter;
 import java.io.ByteArrayOutputStream;
@@ -52,6 +53,7 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
@@ -170,6 +172,7 @@ import org.slf4j.Logger;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.serialization.DynamicOps;
 import com.mojang.serialization.Lifecycle;
+
 import java.util.Random;
 // import jline.console.ConsoleReader; // Paper
 import joptsimple.OptionSet;
@@ -246,7 +249,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private boolean allowFlight;
     @Nullable
     private String motd;
-    @Nullable private net.kyori.adventure.text.Component cachedMotd; // Paper
+    @Nullable
+    private net.kyori.adventure.text.Component cachedMotd; // Paper
     private int playerIdleTimeout;
     public final long[] tickTimes;
     // Paper start
@@ -301,7 +305,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static final int TPS = 20;
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
     private static final int SAMPLE_INTERVAL = 20; // Paper
-    public final double[] recentTps = new double[ 3 ];
+    public final double[] recentTps = new double[3];
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations;
     public static long currentTickLong = 0L; // Paper
@@ -309,7 +313,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile Thread shutdownThread; // Paper
     public volatile boolean abnormalExit = false; // Paper
     public boolean isIteratingOverLevels = false; // Paper
-    
+
     public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning"); // Pufferfish - optimize mob spawning
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
@@ -328,7 +332,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         S s0 = serverFactory.apply(thread); // CraftBukkit - decompile error
 
         atomicreference.set(s0);
-        thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - boost priority
+        thread.setPriority(Thread.NORM_PRIORITY + 2); // Paper - boost priority
         thread.start();
         return s0;
     }
@@ -446,7 +450,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 MinecraftServer.LOGGER.warn("Failed to stop JFR profiling", throwable);
             }
         }
-
     }
 
     // CraftBukkit start
@@ -572,7 +575,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // Paper start - fix and optimise world upgrading
             if (options.has("forceUpgrade")) {
                 net.minecraft.server.Main.convertWorldButItWorks(
-                    dimensionKey, worldSession, DataFixers.getDataFixer(), worlddimension.generator().getTypeNameForDataFixer(), options.has("eraseCache")
+                        dimensionKey, worldSession, DataFixers.getDataFixer(), worlddimension.generator().getTypeNameForDataFixer(), options.has("eraseCache")
                 );
             }
             // Paper end - fix and optimise world upgrading
@@ -640,7 +643,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
     // CraftBukkit end
 
-    protected void forceDifficulty() {}
+    protected void forceDifficulty() {
+    }
 
     // CraftBukkit start
     public void initWorld(ServerLevel worldserver, ServerLevelData iworlddataserver, WorldData saveData, WorldOptions worldoptions) {
@@ -674,7 +678,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             iworlddataserver.setInitialized(true);
         }
-
     }
     // CraftBukkit end
 
@@ -742,7 +745,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     ((ConfiguredFeature) holder_c.value()).place(world, chunkproviderserver.getGenerator(), world.random, new BlockPos(worldProperties.getXSpawn(), worldProperties.getYSpawn(), worldProperties.getZSpawn()));
                 });
             }
-
         }
     }
 
@@ -764,45 +766,44 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // WorldServer worldserver = this.overworld();
         this.forceTicks = true;
         // CraftBukkit end
+        /*
         if (worldserver.getWorld().getKeepSpawnInMemory()) { // Paper
 
-        MinecraftServer.LOGGER.info("Preparing start region for dimension {}", worldserver.dimension().location());
-        BlockPos blockposition = worldserver.getSharedSpawnPos();
+            MinecraftServer.LOGGER.info("Preparing start region for dimension {}", worldserver.dimension().location());
+            BlockPos blockposition = worldserver.getSharedSpawnPos();
 
-        worldloadlistener.updateSpawnPos(new ChunkPos(blockposition));
-        //ChunkProviderServer chunkproviderserver = worldserver.getChunkProvider(); // Paper - move up
+            worldloadlistener.updateSpawnPos(new ChunkPos(blockposition));
+            //ChunkProviderServer chunkproviderserver = worldserver.getChunkProvider(); // Paper - move up
 
-        chunkproviderserver.getLightEngine().setTaskPerBatch(500);
-        this.nextTickTime = Util.getMillis();
-        // Paper start - configurable spawn reason
-        int radiusBlocks = worldserver.paperConfig().spawn.keepSpawnLoadedRange * 16;
-        int radiusChunks = radiusBlocks / 16 + ((radiusBlocks & 15) != 0 ? 1 : 0);
-        int totalChunks = ((radiusChunks) * 2 + 1);
-        totalChunks *= totalChunks;
-        worldloadlistener.setChunkRadius(radiusBlocks / 16);
-
-        worldserver.addTicketsForSpawn(radiusBlocks, blockposition);
-        // Paper end
+            chunkproviderserver.getLightEngine().setTaskPerBatch(500);
+            this.nextTickTime = Util.getMillis();
+            // Paper start - configurable spawn reason
+            int radiusBlocks = worldserver.paperConfig().spawn.keepSpawnLoadedRange * 16;
+            int radiusChunks = radiusBlocks / 16 + ((radiusBlocks & 15) != 0 ? 1 : 0);
+            int totalChunks = ((radiusChunks) * 2 + 1);
+            totalChunks *= totalChunks;
+            worldloadlistener.setChunkRadius(radiusBlocks / 16);
+
+            worldserver.addTicketsForSpawn(radiusBlocks, blockposition);
+            // Paper end
 
-        // this.nextTickTime = SystemUtils.getMillis() + 10L;
-        this.executeModerately();
-        // Iterator iterator = this.levels.values().iterator();
+            // this.nextTickTime = SystemUtils.getMillis() + 10L;
+            this.executeModerately();
+            // Iterator iterator = this.levels.values().iterator();
         }
+         */
 
-        if (true) {
-            ServerLevel worldserver1 = worldserver;
-            // CraftBukkit end
-            ForcedChunksSavedData forcedchunk = (ForcedChunksSavedData) worldserver1.getDataStorage().get(ForcedChunksSavedData::load, "chunks");
+        // CraftBukkit end
+        ForcedChunksSavedData forcedchunk = worldserver.getDataStorage().get(ForcedChunksSavedData::load, "chunks");
 
-            if (forcedchunk != null) {
-                LongIterator longiterator = forcedchunk.getChunks().iterator();
+        if (forcedchunk != null) {
+            LongIterator longiterator = forcedchunk.getChunks().iterator();
 
-                while (longiterator.hasNext()) {
-                    long i = longiterator.nextLong();
-                    ChunkPos chunkcoordintpair = new ChunkPos(i);
+            while (longiterator.hasNext()) {
+                long i = longiterator.nextLong();
+                ChunkPos chunkcoordintpair = new ChunkPos(i);
 
-                    worldserver1.getChunkSource().updateChunkForced(chunkcoordintpair, true);
-                }
+                worldserver.getChunkSource().updateChunkForced(chunkcoordintpair, true);
             }
         }
 
@@ -810,7 +811,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // this.nextTickTime = SystemUtils.getMillis() + 10L;
         this.executeModerately();
         // CraftBukkit end
-        if (worldserver.getWorld().getKeepSpawnInMemory()) worldloadlistener.stop(); // Paper
+        //if (worldserver.getWorld().getKeepSpawnInMemory()) worldloadlistener.stop(); // Paper
         chunkproviderserver.getLightEngine().setTaskPerBatch(worldserver.paperConfig().misc.lightQueueSize); // Paper - increase light queue size
         // CraftBukkit start
         // this.updateMobSpawningFlags();
@@ -839,6 +840,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // This allows us to avoid double saving chunks by closing instead of saving then closing
         return this.saveAllChunks(suppressLogs, flush, force, false);
     }
+
     public boolean saveAllChunks(boolean suppressLogs, boolean flush, boolean force, boolean close) {
         // Paper end - rewrite chunk system - add close param
         boolean flag3 = false;
@@ -850,7 +852,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 MinecraftServer.LOGGER.info("Saving chunks for level '{}'/{}", worldserver, worldserver.dimension().location());
             }
             // Paper start - rewrite chunk system
-            worldserver.save((ProgressListener) null, flush, worldserver.noSave && !force, close);
+            // worldserver.save((ProgressListener) null, flush, worldserver.noSave && !force, close);
             if (flush) {
                 MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver.getChunkSource().chunkMap.getStorageName());
             }
@@ -872,7 +874,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             while (iterator1.hasNext()) {
                 ServerLevel worldserver2 = (ServerLevel) iterator1.next();
-
                 //MinecraftServer.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", worldserver2.getChunkSource().chunkMap.getStorageName()); // Paper - move up
             }
 
@@ -906,6 +907,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile boolean hasFullyShutdown = false; // Paper
     private boolean hasLoggedStop = false; // Paper
     private final Object stopLock = new Object();
+
     public final boolean hasStopped() {
         synchronized (this.stopLock) {
             return this.hasStopped;
@@ -915,11 +917,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public void stopServer() {
         // CraftBukkit start - prevent double stopping on multiple threads
-        synchronized(this.stopLock) {
+        synchronized (this.stopLock) {
             if (this.hasStopped) return;
             this.hasStopped = true;
         }
-        if (!hasLoggedStop && isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper
+        if (!hasLoggedStop && isDebugging())
+            io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper
         // Paper start - kill main thread, and kill it hard
         shutdownThread = Thread.currentThread();
         org.spigotmc.WatchdogThread.doStop(); // Paper
@@ -929,7 +932,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 this.getRunningThread().stop();
                 try {
                     Thread.sleep(1);
-                } catch (InterruptedException e) {}
+                } catch (InterruptedException e) {
+                }
             }
         }
         // Paper end
@@ -956,9 +960,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             MinecraftServer.LOGGER.info("Saving players");
             this.playerList.saveAll();
             this.playerList.removeAll(this.isRestarting); // Paper
-            try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ex) {
+            } // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
         }
 
+        /*
         MinecraftServer.LOGGER.info("Saving worlds");
         Iterator iterator = this.getAllLevels().iterator();
 
@@ -972,7 +980,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         this.saveAllChunks(false, true, false, true); // Paper - rewrite chunk system - move closing into here
-
+        */
         this.isSaving = false;
         this.resources.close();
 
@@ -983,8 +991,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Spigot start
         io.papermc.paper.util.MCUtil.asyncExecutor.shutdown(); // Paper
-        try { io.papermc.paper.util.MCUtil.asyncExecutor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
-        } catch (java.lang.InterruptedException ignored) {} // Paper
+        try {
+            io.papermc.paper.util.MCUtil.asyncExecutor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
+        } catch (java.lang.InterruptedException ignored) {
+        } // Paper
         if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
             MinecraftServer.LOGGER.info("Saving usercache.json");
             this.getProfileCache().save(false); // Paper
@@ -1021,6 +1031,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - allow passing of the intent to restart
         this.safeShutdown(waitForShutdown, false);
     }
+
     public void safeShutdown(boolean waitForShutdown, boolean isRestarting) {
         this.isRestarting = isRestarting;
         this.hasLoggedStop = true; // Paper
@@ -1034,13 +1045,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 MinecraftServer.LOGGER.error("Error while shutting down", interruptedexception);
             }
         }
-
     }
 
     // Spigot Start
-    private static double calcTps(double avg, double exp, double tps)
-    {
-        return ( avg * exp ) + ( tps * ( 1 - exp ) );
+    private static double calcTps(double avg, double exp, double tps) {
+        return (avg * exp) + (tps * (1 - exp));
     }
 
     // Paper start - Further improve server tick loop
@@ -1075,6 +1084,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         private static java.math.BigDecimal dec(long t) {
             return new java.math.BigDecimal(t);
         }
+
         public void add(java.math.BigDecimal x, long t) {
             time -= times[index];
             total = total.subtract(samples[index].multiply(dec(times[index])));
@@ -1091,6 +1101,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
         }
     }
+
     private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
     // Paper End
     // Spigot End
@@ -1124,7 +1135,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             org.spigotmc.WatchdogThread.tick(); // Paper
             org.spigotmc.WatchdogThread.hasStarted = true; // Paper
-            Arrays.fill( recentTps, 20 );
+            Arrays.fill(recentTps, 20);
             long start = System.nanoTime(), curTime, tickSection = start; // Paper - Further improve server tick loop
             lastTick = start - TICK_TIME; // Paper
             while (this.running) {
@@ -1140,14 +1151,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     long j = i / 50L;
 
                     if (this.server.getWarnOnOverload()) // CraftBukkit
-                    MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
+                        MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
                     this.nextTickTime += j * 50L;
                     this.lastOverloadWarning = this.nextTickTime;
                 }
 
                 ++MinecraftServer.currentTickLong; // Paper
-                if ( ++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0 )
-                {
+                if (++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
                     final long diff = curTime - tickSection;
                     java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
                     tps1.add(currentTps, diff);
@@ -1191,9 +1201,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // Paper end
             MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
             // Spigot Start
-            if ( throwable.getCause() != null )
-            {
-                MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable.getCause() );
+            if (throwable.getCause() != null) {
+                MinecraftServer.LOGGER.error("\tCause of unexpected exception was", throwable.getCause());
             }
             // Spigot End
             CrashReport crashreport = MinecraftServer.constructOrExtractCrashReport(throwable);
@@ -1228,9 +1237,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 // CraftBukkit end
                 //this.onServerExit(); // Paper - moved into stop
             }
-
         }
-
     }
 
     private static CrashReport constructOrExtractCrashReport(Throwable throwable) {
@@ -1271,6 +1278,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     // Paper start
     boolean isOversleep = false;
+
     private boolean canOversleep() {
         return this.mayHaveDelayedTasks && Util.getMillis() < this.delayedTasksMaxNextTickTime;
     }
@@ -1298,7 +1306,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - anything that does try to post to main during watchdog crash, run on watchdog
         if (this.hasStopped && Thread.currentThread().equals(shutdownThread)) {
             runnable.run();
-            runnable = () -> {};
+            runnable = () -> {
+            };
         }
         // Paper end
         return new TickTask(this.tickCount, runnable);
@@ -1366,7 +1375,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             } catch (Exception exception) {
                 MinecraftServer.LOGGER.error("Couldn't load server icon", exception);
             }
-
         });
     }
 
@@ -1378,22 +1386,26 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return new File(".");
     }
 
-    public void onServerCrash(CrashReport report) {}
+    public void onServerCrash(CrashReport report) {
+    }
 
-    public void onServerExit() {}
+    public void onServerExit() {
+    }
 
     public void tickServer(BooleanSupplier shouldKeepTicking) {
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         long i = Util.getNanos();
 
         // Paper start - move oversleep into full server tick
-        isOversleep = true;MinecraftTimings.serverOversleep.startTiming();
+        isOversleep = true;
+        MinecraftTimings.serverOversleep.startTiming();
         this.managedBlock(() -> {
             return !this.canOversleep();
         });
-        isOversleep = false;MinecraftTimings.serverOversleep.stopTiming();
+        isOversleep = false;
+        MinecraftTimings.serverOversleep.stopTiming();
         // Paper end
-        new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper
+        new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount + 1).callEvent(); // Paper
 
         ++this.tickCount;
         this.tickChildren(shouldKeepTicking);
@@ -1425,6 +1437,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             playerSaveInterval = autosavePeriod;
         }
         this.profiler.push("save");
+        /*
         final boolean fullSave = autosavePeriod > 0 && this.tickCount % autosavePeriod == 0;
         try {
             this.isSaving = true;
@@ -1439,6 +1452,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } finally {
             this.isSaving = false;
         }
+         */
         this.profiler.pop();
         // Paper end
         io.papermc.paper.util.CachedLists.reset(); // Paper
@@ -1450,7 +1464,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start
         long endTime = System.nanoTime();
         long remaining = (TICK_TIME - (endTime - lastTick)) - catchupTime;
-        new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.tickCount, ((double)(endTime - lastTick) / 1000000D), remaining).callEvent();
+        new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.tickCount, ((double) (endTime - lastTick) / 1000000D), remaining).callEvent();
         // Paper end
         this.profiler.push("tallying");
         long l = this.tickTimes[this.tickCount % 100] = Util.getNanos() - i;
@@ -1504,7 +1518,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 ServerPlayer entityplayer = (ServerPlayer) entityhuman;
                 long playerTime = entityplayer.getPlayerTime();
                 ClientboundSetTimePacket packet = (playerTime == dayTime) ? worldPacket :
-                    new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
+                        new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
                 entityplayer.connection.send(packet); // Add support for per player time
             }
         }
@@ -1515,8 +1529,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Iterator iterator = this.getAllLevels().iterator(); // Paper - move down
         while (iterator.hasNext()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+            worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+            worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
             net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
 
             this.profiler.push(() -> {
@@ -1547,7 +1561,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 try {
                     crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
                 } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath) throwable;
+                    } // Paper
                     throw new RuntimeException("Error generating crash report", t);
                 }
                 // Spigot End
@@ -1762,7 +1778,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             worldserver.setSpawnSettings(worldserver.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && ((DedicatedServer) this).settings.getProperties().spawnMonsters, this.isSpawningAnimals()); // Paper - per level difficulty (from setDifficulty(ServerLevel, Difficulty, boolean))
         }
-
     }
 
     public void setDifficultyLocked(boolean locked) {
@@ -2009,6 +2024,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public CompletableFuture<Void> reloadResources(Collection<String> dataPacks) {
         return this.reloadResources(dataPacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause.PLUGIN);
     }
+
     public CompletableFuture<Void> reloadResources(Collection<String> dataPacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause cause) {
         // Paper end
         RegistryAccess.Frozen iregistrycustom_dimension = this.registries.getAccessForLoading(RegistryLayer.RELOADABLE);
@@ -2025,7 +2041,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 if (throwable != null) {
                     resourcemanager.close();
                 }
-
             }).thenApply((datapackresources) -> {
                 return new MinecraftServer.ReloadableResources(resourcemanager, datapackresources);
             });
@@ -2135,7 +2150,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (this.isEnforceWhitelist()) {
             PlayerList playerlist = source.getServer().getPlayerList();
             UserWhiteList whitelist = playerlist.getWhiteList();
-            if (!((DedicatedServer)getServer()).getProperties().whiteList.get()) return; // Paper - white list not enabled
+            if (!((DedicatedServer) getServer()).getProperties().whiteList.get())
+                return; // Paper - white list not enabled
             List<ServerPlayer> list = Lists.newArrayList(playerlist.getPlayers());
             Iterator iterator = list.iterator();
 
@@ -2146,7 +2162,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     entityplayer.connection.disconnect(org.spigotmc.SpigotConfig.whitelistMessage, org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message
                 }
             }
-
         }
     }
 
@@ -2240,13 +2255,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public ProfilerFiller getProfiler() {
-        if (gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler) return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
+        if (gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler)
+            return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
         return this.profiler;
     }
 
     public abstract boolean isSingleplayerOwner(GameProfile profile);
 
-    public void dumpServerProperties(Path file) throws IOException {}
+    public void dumpServerProperties(Path file) throws IOException {
+    }
 
     private void saveDebugReport(Path path) {
         Path path1 = path.resolve("levels");
@@ -2272,7 +2289,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } catch (IOException ioexception) {
             MinecraftServer.LOGGER.warn("Failed to save debug report", ioexception);
         }
-
     }
 
     private void dumpMiscStats(Path path) throws IOException {
@@ -2298,7 +2314,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (bufferedwriter != null) {
             bufferedwriter.close();
         }
-
     }
 
     private void dumpGameRules(Path path) throws IOException {
@@ -2336,7 +2351,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (bufferedwriter != null) {
             bufferedwriter.close();
         }
-
     }
 
     private void dumpClasspath(Path path) throws IOException {
@@ -2368,7 +2382,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (bufferedwriter != null) {
             bufferedwriter.close();
         }
-
     }
 
     private void dumpThreads(Path path) throws IOException {
@@ -2403,7 +2416,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (bufferedwriter != null) {
             bufferedwriter.close();
         }
-
     }
 
     private void dumpNativeModules(Path path) throws IOException {
@@ -2461,7 +2473,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (bufferedwriter != null) {
             bufferedwriter.close();
         }
-
     }
 
     // CraftBukkit start
@@ -2602,7 +2613,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } else {
             MinecraftServer.LOGGER.info("{}", s1);
         }
-
     }
 
     // CraftBukkit start
@@ -2619,7 +2629,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // CraftBukkit end
     }
 
-    public static record ReloadableResources(CloseableResourceManager resourceManager, ReloadableServerResources managers) implements AutoCloseable {
+    public static record ReloadableResources(CloseableResourceManager resourceManager,
+                                             ReloadableServerResources managers) implements AutoCloseable {
 
         public void close() {
             this.resourceManager.close();
@@ -2676,7 +2687,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    public static record ServerResourcePackInfo(String url, String hash, boolean isRequired, @Nullable Component prompt) {
+    public static record ServerResourcePackInfo(String url, String hash, boolean isRequired,
+                                                @Nullable Component prompt) {
 
     }
 
@@ -2746,7 +2758,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming();
         try {
-            for (;;) {
+            for (; ; ) {
                 boolean moreTasks = this.tickMidTickTasks();
                 long currTime = System.nanoTime();
                 long diff = currTime - startTime;
@@ -2763,8 +2775,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                         overuse = 10L * 1000L * 1000L; // 10ms
                     }
 
-                    double overuseCount = (double)overuse/(double)MAX_CHUNK_EXEC_TIME;
-                    long extraSleep = (long)Math.round(overuseCount*CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME);
+                    double overuseCount = (double) overuse / (double) MAX_CHUNK_EXEC_TIME;
+                    long extraSleep = (long) Math.round(overuseCount * CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME);
 
                     lastMidTickExecute = currTime + extraSleep;
                     return;
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index ad4fdbdcf09f30d10e61ccf47f8fb9ce6bd92e73..cfe4c90b2d5e940bdd23167dcc288cfa164ff390 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -302,18 +302,14 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             return false;
         } else {
             // this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage)); // CraftBukkit - moved up
-            long i = Util.getNanos();
 
             SkullBlockEntity.setup(this.services, this);
             GameProfileCache.setUsesAuthentication(this.usesAuthentication());
             DedicatedServer.LOGGER.info("Preparing level \"{}\"", this.getLevelIdName());
             this.loadLevel(storageSource.getLevelId()); // CraftBukkit
-            long j = Util.getNanos() - i;
-            String s = String.format(Locale.ROOT, "%.3fs", (double) j / 1.0E9D);
 
-            //DedicatedServer.LOGGER.info("Done ({})! For help, type \"help\"", s); // Paper moved to after init
             if (dedicatedserverproperties.announcePlayerAchievements != null) {
-                ((GameRules.BooleanValue) this.getGameRules().getRule(GameRules.RULE_ANNOUNCE_ADVANCEMENTS)).set(dedicatedserverproperties.announcePlayerAchievements, null); // Paper
+                this.getGameRules().getRule(GameRules.RULE_ANNOUNCE_ADVANCEMENTS).set(dedicatedserverproperties.announcePlayerAchievements, null); // Paper
             }
 
             if (dedicatedserverproperties.enableQuery) {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index c6f5d6756fa0e068a462d9c0ded12e0771abba37..60163611bfd4dc149b2dffe2f0ed7eb147d723ae 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -712,6 +712,7 @@ public class ServerChunkCache extends ChunkSource {
 
             gameprofilerfiller.push("naturalSpawnCount");
             this.level.timings.countNaturalMobs.startTiming(); // Paper - timings
+            /*
             int l = this.distanceManager.getNaturalSpawnChunkCount();
             // Paper start - per player mob spawning
             NaturalSpawner.SpawnState spawnercreature_d; // moved down
@@ -731,6 +732,7 @@ public class ServerChunkCache extends ChunkSource {
                 _pufferfish_spawnCountsReady.set(true);
                 // Pufferfish end
             }
+             */
             // Paper end
             this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
 
@@ -742,6 +744,7 @@ public class ServerChunkCache extends ChunkSource {
             // Paper - moved down
 
             gameprofilerfiller.popPush("spawnAndTick");
+            /*
             boolean flag2 = this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !this.level.players().isEmpty(); // CraftBukkit
 
             // Paper - only shuffle if per-player mob spawning is disabled
@@ -770,16 +773,15 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper end - optimise chunk tick iteration
                 ChunkPos chunkcoordintpair = chunk1.getPos();
 
-                if ((true || this.level.isNaturalSpawningAllowed(chunkcoordintpair)) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning // Paper - the chunk is known ticking
+                if (this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning // Paper - the chunk is known ticking
                     chunk1.incrementInhabitedTime(j);
                     if (flag2 && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
                         NaturalSpawner.spawnForChunk(this.level, chunk1, lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag1); // Pufferfish
                     }
 
-                    if (true || this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - the chunk is known ticking
-                        this.level.tickChunk(chunk1, k);
-                        if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
-                    }
+                    // Paper - the chunk is known ticking
+                    this.level.tickChunk(chunk1, k);
+                    if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
                 }
                 // Paper start - optimise chunk tick iteration
                 }
@@ -790,14 +792,17 @@ public class ServerChunkCache extends ChunkSource {
                     safeIterator.finishedIterating();
                 }
             }
+             */
             // Paper end - optimise chunk tick iteration
             this.level.timings.chunkTicks.stopTiming(); // Paper
             gameprofilerfiller.popPush("customSpawners");
+            /*
             if (flag2) {
                 try (co.aikar.timings.Timing ignored = this.level.timings.miscMobSpawning.startTiming()) { // Paper - timings
                 this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
                 } // Paper - timings
             }
+             */
             gameprofilerfiller.pop();
             // Paper start - use set of chunks requiring updates, rather than iterating every single one loaded
             gameprofilerfiller.popPush("broadcast");
@@ -837,6 +842,7 @@ public class ServerChunkCache extends ChunkSource {
         }
     
         // Pufferfish start - optimize mob spawning
+        /*
         if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) {
             for (ServerPlayer player : this.level.players) {
                 Arrays.fill(player.mobCounts, 0);
@@ -858,6 +864,7 @@ public class ServerChunkCache extends ChunkSource {
                 });
             }
         }
+         */
         // Pufferfish end
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 53198ebfa30273c5ddc1bb4324f5174ff99f688d..cc27c60be05c8d57f590afdd70e690a66f90ec3f 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -639,6 +639,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         gameprofilerfiller.push("world border");
         this.getWorldBorder().tick();
         gameprofilerfiller.popPush("weather");
+        /*
         this.advanceWeatherCycle();
         int i = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
         long j;
@@ -662,13 +663,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 this.resetWeatherCycle();
             }
         }
-
         this.updateSkyBrightness();
+         */
         this.tickTime();
         gameprofilerfiller.popPush("tickPending");
         timings.scheduledBlocks.startTiming(); // Paper
         if (!this.isDebug()) {
-            j = this.getGameTime();
+            long j = this.getGameTime();
             gameprofilerfiller.push("blockTicks");
             this.blockTicks.tick(j, 65536, this::tickBlock);
             gameprofilerfiller.popPush("fluidTicks");
@@ -678,9 +679,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
         timings.scheduledBlocks.stopTiming(); // Paper
 
         gameprofilerfiller.popPush("raid");
-        this.timings.raids.startTiming(); // Paper - timings
-        this.raids.tick();
-        this.timings.raids.stopTiming(); // Paper - timings
+        // this.timings.raids.startTiming(); // Paper - timings
+        // this.raids.tick();
+        // this.timings.raids.stopTiming(); // Paper - timings
         gameprofilerfiller.popPush("chunkSource");
         this.timings.chunkProviderTick.startTiming(); // Paper - timings
         this.getChunkSource().tick(shouldKeepTicking, true);
@@ -691,68 +692,62 @@ public class ServerLevel extends Level implements WorldGenLevel {
         timings.doSounds.stopTiming(); // Spigot
         this.handlingTick = false;
         gameprofilerfiller.pop();
-        boolean flag = true || !this.players.isEmpty() || !this.getForcedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
 
-        if (flag) {
-            this.resetEmptyTime();
+        gameprofilerfiller.push("entities");
+        timings.tickEntities.startTiming(); // Spigot
+
+        /*
+        if (this.dragonFight != null) {
+            gameprofilerfiller.push("dragonFight");
+            this.dragonFight.tick();
+            gameprofilerfiller.pop();
         }
+         */
 
-        if (flag || this.emptyTime++ < 300) {
-            gameprofilerfiller.push("entities");
-            timings.tickEntities.startTiming(); // Spigot
-            if (this.dragonFight != null) {
-                gameprofilerfiller.push("dragonFight");
-                this.dragonFight.tick();
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
+        this.entityTickList.forEach((entity) -> {
+            entity.activatedPriorityReset = false; // Pufferfish - DAB
+            if (!entity.isRemoved()) {
+                gameprofilerfiller.push("checkDespawn");
+                entity.checkDespawn();
                 gameprofilerfiller.pop();
-            }
+                if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
+                    Entity entity1 = entity.getVehicle();
 
-            org.spigotmc.ActivationRange.activateEntities(this); // Spigot
-            timings.entityTick.startTiming(); // Spigot
-            this.entityTickList.forEach((entity) -> {
-                entity.activatedPriorityReset = false; // Pufferfish - DAB
-                if (!entity.isRemoved()) {
-                    if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
-                        entity.discard();
-                    } else {
-                        gameprofilerfiller.push("checkDespawn");
-                        entity.checkDespawn();
-                        gameprofilerfiller.pop();
-                        if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
-                            Entity entity1 = entity.getVehicle();
-
-                            if (entity1 != null) {
-                                if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
-                                    return;
-                                }
+                    if (entity1 != null) {
+                        if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
+                            return;
+                        }
 
-                                entity.stopRiding();
-                            }
+                        entity.stopRiding();
+                    }
 
-                            gameprofilerfiller.push("tick");
-                        // Pufferfish start - copied from this.guardEntityTick
-                        try {
-                            this.tickNonPassenger(entity); // Pufferfish - changed
-                            MinecraftServer.getServer().executeMidTickTasks(); // Tuinity - execute chunk tasks mid tick
-                        } catch (Throwable throwable) {
-                            if (throwable instanceof ThreadDeath) throw throwable; // Paper
-                            // Paper start - Prevent tile entity and entity crashes
-                            final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level.getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
-                            MinecraftServer.LOGGER.error(msg, throwable);
-                            getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, throwable)));
-                            entity.discard();
-                            // Paper end
-                        }
-                        // Pufferfish end
-                            gameprofilerfiller.pop();
-                        }
+                    gameprofilerfiller.push("tick");
+                    // Pufferfish start - copied from this.guardEntityTick
+                    try {
+
+                        this.tickNonPassenger(entity); // Pufferfish - changed
+                        MinecraftServer.getServer().executeMidTickTasks(); // Tuinity - execute chunk tasks mid tick
+                    } catch (Throwable throwable) {
+                        if (throwable instanceof ThreadDeath) throw throwable; // Paper
+                        // Paper start - Prevent tile entity and entity crashes
+                        final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level.getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
+                        MinecraftServer.LOGGER.error(msg, throwable);
+                        getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, throwable)));
+                        entity.discard();
+                        // Paper end
                     }
+                    // Pufferfish end
+                    gameprofilerfiller.pop();
                 }
-            });
-            timings.entityTick.stopTiming(); // Spigot
-            timings.tickEntities.stopTiming(); // Spigot
-            gameprofilerfiller.pop();
-            this.tickBlockEntities();
-        }
+            }
+        });
+        timings.entityTick.stopTiming(); // Spigot
+        timings.tickEntities.stopTiming(); // Spigot
+        gameprofilerfiller.pop();
+        this.tickBlockEntities();
+
 
         gameprofilerfiller.push("entityManagement");
         //this.entityManager.tick(); // Paper - rewrite chunk system
@@ -814,15 +809,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
         ChunkPos chunkcoordintpair = chunk.getPos();
-        boolean flag = this.isRaining();
-        int j = chunkcoordintpair.getMinBlockX();
-        int k = chunkcoordintpair.getMinBlockZ();
         ProfilerFiller gameprofilerfiller = this.getProfiler();
 
         gameprofilerfiller.push("thunder");
+        /*
         final BlockPos.MutableBlockPos blockposition = this.chunkTickMutablePosition; // Paper - use mutable to reduce allocation rate, final to force compile fail on change
 
-        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && /*this.random.nextInt(this.spigotConfig.thunderChance) == 0 &&*/ chunk.shouldDoLightning(this.random)) { // Spigot // Paper - disable thunder // Pufferfish - replace random with shouldDoLightning
+        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && chunk.shouldDoLightning(this.random)) { // Spigot // Paper - disable thunder // Pufferfish - replace random with shouldDoLightning
             blockposition.set(this.findLightningTargetAround(this.getBlockRandomPos(j, 0, k, 15))); // Paper
             if (this.isRainingAt(blockposition)) {
                 DifficultyInstance difficultydamagescaler = this.getCurrentDifficultyAt(blockposition);
@@ -848,8 +841,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 }
             }
         }
+         */
 
         gameprofilerfiller.popPush("iceandsnow");
+        /*
         int l;
 
         if (!this.paperConfig().environment.disableIceAndSnow && (this.currentIceAndSnowTick++ & 15) == 0) { // Paper - Disable ice and snow // Paper - optimise random ticking  // Pufferfish - optimize further random ticking
@@ -899,10 +894,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 iblockdata.getBlock().handlePrecipitation(iblockdata, this, blockposition, biomebase_precipitation); // Paper
             }
         }
+         */
 
         // Paper start - optimise random block ticking
         gameprofilerfiller.popPush("randomTick");
         timings.chunkTicksBlocks.startTiming(); // Paper
+        /*
         if (randomTickSpeed > 0) {
             LevelChunkSection[] sections = chunk.getSections();
             int minSection = io.papermc.paper.util.WorldUtil.getMinSection(this);
@@ -935,6 +932,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 }
             }
         }
+         */
         // Paper end - optimise random block ticking
         timings.chunkTicksBlocks.stopTiming(); // Paper
         gameprofilerfiller.pop();
@@ -991,6 +989,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void announceSleepStatus() {
+        /*
         if (this.canSleepThroughNights()) {
             if (!this.getServer().isSingleplayer() || this.getServer().isPublished()) {
                 int i = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
@@ -1012,13 +1011,15 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
             }
         }
+         */
     }
 
     public void updateSleepingPlayerList() {
+        /*
         if (!this.players.isEmpty() && this.sleepStatus.update(this.players)) {
             this.announceSleepStatus();
         }
-
+         */
     }
 
     @Override
@@ -1198,9 +1199,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 currentlyTickingEntity.lazySet(entity);
             }
             // Paper end - log detailed entity tick information
-        ++TimingHistory.entityTicks; // Paper - timings
-        // Spigot start
-        co.aikar.timings.Timing timer; // Paper
+            ++TimingHistory.entityTicks; // Paper - timings
+            // Spigot start
+            co.aikar.timings.Timing timer; // Paper
         /*if (!org.spigotmc.ActivationRange.checkIfActive(entity)) { // Paper - comment out - EAR 2, reimplement below
             entity.tickCount++;
             timer = entity.getType().inactiveTickTimer.startTiming(); try { // Paper - timings
@@ -1208,36 +1209,40 @@ public class ServerLevel extends Level implements WorldGenLevel {
             } finally { timer.stopTiming(); } // Paper
             return;
         }*/ // Paper - comment out EAR 2
-        // Spigot end
-        // Paper start- timings
-        final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity);
-        timer = isActive ? entity.getType().tickTimer.startTiming() : entity.getType().inactiveTickTimer.startTiming(); // Paper
-        try {
-        // Paper end - timings
-        entity.setOldPosAndRot();
-        ProfilerFiller gameprofilerfiller = this.getProfiler();
+            // Spigot end
+            // Paper start- timings
+            final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity);
+            timer = isActive ? entity.getType().tickTimer.startTiming() : entity.getType().inactiveTickTimer.startTiming(); // Paper
+            try {
+                // Paper end - timings
+                entity.setOldPosAndRot();
+                ProfilerFiller gameprofilerfiller = this.getProfiler();
 
-        ++entity.tickCount;
-        this.getProfiler().push(() -> {
-            return BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType()).toString();
-        });
-        gameprofilerfiller.incrementCounter("tickNonPassenger");
-        if (isActive) { // Paper - EAR 2
-            TimingHistory.activatedEntityTicks++;
-        entity.tick();
-        entity.postTick(); // CraftBukkit
-        } else { entity.inactiveTick(); } // Paper - EAR 2
-        this.getProfiler().pop();
-        } finally { timer.stopTiming(); } // Paper - timings
-        Iterator iterator = entity.getPassengers().iterator();
+                ++entity.tickCount;
+                this.getProfiler().push(() -> {
+                    return BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType()).toString();
+                });
+                gameprofilerfiller.incrementCounter("tickNonPassenger");
+                if (isActive) { // Paper - EAR 2
+                    TimingHistory.activatedEntityTicks++;
+                    entity.tick();
+                    entity.postTick(); // CraftBukkit
+                } else {
+                    entity.inactiveTick();
+                } // Paper - EAR 2
+                this.getProfiler().pop();
+            } finally {
+                timer.stopTiming();
+            } // Paper - timings
+            Iterator iterator = entity.getPassengers().iterator();
 
-        while (iterator.hasNext()) {
-            Entity entity1 = (Entity) iterator.next();
+            while (iterator.hasNext()) {
+                Entity entity1 = (Entity) iterator.next();
 
-            this.tickPassenger(entity, entity1);
-        }
-        // } finally { timer.stopTiming(); } // Paper - timings - move up
-        // Paper start - log detailed entity tick information
+                this.tickPassenger(entity, entity1);
+            }
+            // } finally { timer.stopTiming(); } // Paper - timings - move up
+            // Paper start - log detailed entity tick information
         } finally {
             if (currentlyTickingEntity.get() == entity) {
                 currentlyTickingEntity.lazySet(null);
diff --git a/src/main/java/net/minecraft/stats/ServerRecipeBook.java b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
index d13ed3069e944d138442ea440ac3eaf8d44c18d3..87f7d05dea4667e8c9972400dfd79d1ce5194af8 100644
--- a/src/main/java/net/minecraft/stats/ServerRecipeBook.java
+++ b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
@@ -114,6 +114,7 @@ public class ServerRecipeBook extends RecipeBook {
     }
 
     private void loadRecipes(ListTag list, Consumer<Recipe<?>> handler, RecipeManager recipeManager) {
+        /*
         for (int i = 0; i < list.size(); ++i) {
             String s = list.getString(i);
 
@@ -130,7 +131,7 @@ public class ServerRecipeBook extends RecipeBook {
                 ServerRecipeBook.LOGGER.error("Tried to load improperly formatted recipe: {} removed now.", s);
             }
         }
-
+         */
     }
 
     public void sendInitialRecipeBook(ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 3073b34a0e0281b6b0330721bb0440147de28511..1959a7dd73340052e777eddf94cb401a1d16ac5f 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -280,6 +280,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public static final String UUID_TAG = "UUID";
     private static double viewScale = 1.0D;
     private final EntityType<?> type;
+
     private int id;
     public boolean blocksBuilding;
     public ImmutableList<Entity> passengers;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 413652284e229a51e3eefe47f239e8fa9a09ccb2..610ea75a2016cf939ede43c0c082970773d792a8 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -8,6 +8,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import java.util.Collection;
@@ -76,6 +77,9 @@ import net.minecraft.world.entity.ai.attributes.AttributeModifier;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.attributes.DefaultAttributes;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.sensing.Sensor;
+import net.minecraft.world.entity.ai.sensing.SensorType;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
 import net.minecraft.world.entity.animal.Animal;
 import net.minecraft.world.entity.animal.FlyingAnimal;
@@ -127,6 +131,8 @@ import org.slf4j.Logger;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Set;
+import java.util.function.Supplier;
+
 import com.google.common.base.Function;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
@@ -866,10 +872,11 @@ public abstract class LivingEntity extends Entity {
                 this.setPosToBed(blockposition);
             }
         }
-
+        /*
         if (nbt.contains("Brain", 10)) {
             this.brain = this.makeBrain(new Dynamic(NbtOps.INSTANCE, nbt.get("Brain")));
         }
+         */
 
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Zombie.java b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
index 9976205537cfe228735687f1e9c52c74ac025690..e6033c6e19dce9453e1518057b1641c345cfbc7c 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Zombie.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
@@ -315,18 +315,13 @@ public class Zombie extends Monster {
 
     @Override
     public boolean hurt(DamageSource source, float amount) {
-        if (!super.hurt(source, amount)) {
-            return false;
-        } else if (!(this.level instanceof ServerLevel)) {
-            return false;
-        } else {
+        /*
             ServerLevel worldserver = (ServerLevel) this.level;
             LivingEntity entityliving = this.getTarget();
 
             if (entityliving == null && source.getEntity() instanceof LivingEntity) {
                 entityliving = (LivingEntity) source.getEntity();
             }
-
             if (entityliving != null && this.level.getDifficulty() == Difficulty.HARD && (double) this.random.nextFloat() < this.getAttributeValue(Attributes.SPAWN_REINFORCEMENTS_CHANCE) && this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)) {
                 int i = Mth.floor(this.getX());
                 int j = Mth.floor(this.getY());
@@ -354,9 +349,10 @@ public class Zombie extends Monster {
                     }
                 }
             }
-
-            return true;
-        }
+             */
+        if (!super.hurt(source, amount)) {
+            return false;
+        } else return this.level instanceof ServerLevel;
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java b/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
index f224ebbc0efefddede43d87f0300c014077b9931..0713f7a29f6fa0d3c8ae4a24f87255d6a26937b4 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
@@ -69,6 +69,7 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                     Bukkit.getPluginManager().callEvent(teleEvent);
 
                     if (!teleEvent.isCancelled() && !entityplayer.connection.isDisconnected()) {
+                        /*
                         if (this.random.nextFloat() < 0.05F && this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)) {
                             Endermite entityendermite = (Endermite) EntityType.ENDERMITE.create(this.level);
 
@@ -77,6 +78,7 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                                 this.level.addFreshEntity(entityendermite, CreatureSpawnEvent.SpawnReason.ENDER_PEARL);
                             }
                         }
+                         */
 
                         if (entity.isPassenger()) {
                             entity.stopRiding();
diff --git a/src/main/java/net/minecraft/world/inventory/CraftingMenu.java b/src/main/java/net/minecraft/world/inventory/CraftingMenu.java
index c6820f22abdd9d1d3e065620c19ab93645e07bb7..0a4c8d4350c2b5c1fba55f41d59a9d7f97a86126 100644
--- a/src/main/java/net/minecraft/world/inventory/CraftingMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/CraftingMenu.java
@@ -72,6 +72,7 @@ public class CraftingMenu extends RecipeBookMenu<CraftingContainer> {
     }
 
     protected static void slotChangedCraftingGrid(AbstractContainerMenu handler, Level world, Player player, CraftingContainer craftingInventory, ResultContainer resultInventory) {
+        /*
         if (!world.isClientSide) {
             ServerPlayer entityplayer = (ServerPlayer) player;
             ItemStack itemstack = ItemStack.EMPTY;
@@ -94,13 +95,16 @@ public class CraftingMenu extends RecipeBookMenu<CraftingContainer> {
             handler.setRemoteSlot(0, itemstack);
             entityplayer.connection.send(new ClientboundContainerSetSlotPacket(handler.containerId, handler.incrementStateId(), 0, itemstack));
         }
+         */
     }
 
     @Override
     public void slotsChanged(Container inventory) {
+        /*
         this.access.execute((world, blockposition) -> {
             CraftingMenu.slotChangedCraftingGrid(this, world, this.player, this.craftSlots, this.resultSlots);
         });
+         */
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
index 2f712bfc1f717ba410bf34669d7b0a919ca218cc..75a6a961da1c24eef2c6e63b1cb933ea12bec9fa 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
@@ -50,6 +50,7 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
 
     protected void apply(Map<ResourceLocation, JsonElement> prepared, ResourceManager manager, ProfilerFiller profiler) {
         this.hasErrors = false;
+        /*
         // CraftBukkit start - SPIGOT-5667 make sure all types are populated and mutable
         Map<RecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, Recipe<?>>> map1 = Maps.newHashMap();
         for (RecipeType<?> recipeType : BuiltInRegistries.RECIPE_TYPE) {
@@ -82,6 +83,7 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
         }));
         this.byName = Maps.newHashMap(builder.build()); // CraftBukkit
         RecipeManager.LOGGER.info("Loaded {} recipes", map1.size());
+         */
     }
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index 5521418fa307b3eeb4f02a10c39f05b360d1d06e..b16a7d99315775b48c569b546d28fb6c981bdc0f 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -132,6 +132,7 @@ public final class NaturalSpawner {
     }
 
     public static void spawnForChunk(ServerLevel world, LevelChunk chunk, NaturalSpawner.SpawnState info, boolean spawnAnimals, boolean spawnMonsters, boolean rareSpawn) {
+        /*
         world.getProfiler().push("spawner");
         world.timings.mobSpawn.startTiming(); // Spigot
         MobCategory[] aenumcreaturetype = NaturalSpawner.SPAWNING_CATEGORIES;
@@ -190,6 +191,7 @@ public final class NaturalSpawner {
 
         world.timings.mobSpawn.stopTiming(); // Spigot
         world.getProfiler().pop();
+         */
     }
 
     // Paper start
@@ -204,32 +206,38 @@ public final class NaturalSpawner {
 
     public static void spawnCategoryForChunk(MobCategory group, ServerLevel world, LevelChunk chunk, NaturalSpawner.SpawnPredicate checker, NaturalSpawner.AfterSpawnCallback runner) {
         // Paper start - add parameters and int ret type
-        spawnCategoryForChunk(group, world, chunk, checker, runner, Integer.MAX_VALUE, null);
+        // spawnCategoryForChunk(group, world, chunk, checker, runner, Integer.MAX_VALUE, null);
     }
     public static int spawnCategoryForChunk(MobCategory group, ServerLevel world, LevelChunk chunk, NaturalSpawner.SpawnPredicate checker, NaturalSpawner.AfterSpawnCallback runner, int maxSpawns, Consumer<Entity> trackEntity) {
         // Paper end - add parameters and int ret type
+        /*
         BlockPos blockposition = NaturalSpawner.getRandomPosWithin(world, chunk);
 
         if (blockposition.getY() >= world.getMinBuildHeight() + 1) {
             return NaturalSpawner.spawnCategoryForPosition(group, world, chunk, blockposition, checker, runner, maxSpawns, trackEntity); // Paper
         }
         return 0; // Paper
+         */
+        return 0;
     }
 
     @VisibleForDebug
     public static void spawnCategoryForPosition(MobCategory group, ServerLevel world, BlockPos pos) {
+        /*
         NaturalSpawner.spawnCategoryForPosition(group, world, world.getChunk(pos), pos, (entitytypes, blockposition1, ichunkaccess) -> {
             return true;
         }, (entityinsentient, ichunkaccess) -> {
         });
+         */
     }
 
     // Paper start - add maxSpawns parameter and return spawned mobs
     public static void spawnCategoryForPosition(MobCategory group, ServerLevel world, ChunkAccess chunk, BlockPos pos, NaturalSpawner.SpawnPredicate checker, NaturalSpawner.AfterSpawnCallback runner) {
-        spawnCategoryForPosition(group, world,chunk, pos, checker, runner, Integer.MAX_VALUE, null);
+        // spawnCategoryForPosition(group, world,chunk, pos, checker, runner, Integer.MAX_VALUE, null);
     }
     public static int spawnCategoryForPosition(MobCategory group, ServerLevel world, ChunkAccess chunk, BlockPos pos, NaturalSpawner.SpawnPredicate checker, NaturalSpawner.AfterSpawnCallback runner, int maxSpawns, Consumer<Entity> trackEntity) {
     // Paper end - add maxSpawns parameter and return spawned mobs
+        /*
         StructureManager structuremanager = world.structureManager();
         ChunkGenerator chunkgenerator = world.getChunkSource().getGenerator();
         int i = pos.getY();
@@ -331,10 +339,12 @@ public final class NaturalSpawner {
 
         }
         return j; // Paper
+         */
+        return 0;
     }
 
     private static boolean isRightDistanceToPlayerAndSpawnPoint(ServerLevel world, ChunkAccess chunk, BlockPos.MutableBlockPos pos, double squaredDistance) {
-        return squaredDistance <= 576.0D ? false : (world.getSharedSpawnPos().closerToCenterThan(new Vec3((double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D), 24.0D) ? false : Objects.equals(new ChunkPos(pos), chunk.getPos()) || world.isNaturalSpawningAllowed((BlockPos) pos)); // Paper - diff on change, copy into caller
+        return !(squaredDistance <= 576.0D) && (!world.getSharedSpawnPos().closerToCenterThan(new Vec3((double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D), 24.0D) && (Objects.equals(new ChunkPos(pos), chunk.getPos()) || world.isNaturalSpawningAllowed((BlockPos) pos))); // Paper - diff on change, copy into caller
     }
 
     private static Boolean isValidSpawnPostitionForType(ServerLevel world, MobCategory group, StructureManager structureAccessor, ChunkGenerator chunkGenerator, MobSpawnSettings.SpawnerData spawnEntry, BlockPos.MutableBlockPos pos, double squaredDistance) { // Paper
@@ -457,6 +467,7 @@ public final class NaturalSpawner {
     }
 
     public static void spawnMobsForChunkGeneration(ServerLevelAccessor world, Holder<Biome> biomeEntry, ChunkPos chunkPos, RandomSource random) {
+        /*
         MobSpawnSettings biomesettingsmobs = ((Biome) biomeEntry.value()).getMobSettings();
         WeightedRandomList<MobSpawnSettings.SpawnerData> weightedrandomlist = biomesettingsmobs.getMobs(MobCategory.CREATURE);
 
@@ -528,6 +539,7 @@ public final class NaturalSpawner {
             }
 
         }
+         */
     }
 
     private static BlockPos getTopNonCollidingPos(LevelReader world, EntityType<?> entityType, int x, int z) {
diff --git a/src/main/java/net/minecraft/world/level/block/NetherPortalBlock.java b/src/main/java/net/minecraft/world/level/block/NetherPortalBlock.java
index 192689be9dfc9373876921bd4da0715d58f9421c..e20119f66ff8e6b474a7735be4ade1331d7d619d 100644
--- a/src/main/java/net/minecraft/world/level/block/NetherPortalBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/NetherPortalBlock.java
@@ -52,6 +52,7 @@ public class NetherPortalBlock extends Block {
 
     @Override
     public void randomTick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
+        /*
         if (world.spigotConfig.enableZombiePigmenPortalSpawns && world.dimensionType().natural() && world.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && random.nextInt(2000) < world.getDifficulty().getId()) { // Spigot
             while (world.getBlockState(pos).is((Block) this)) {
                 pos = pos.below();
@@ -68,7 +69,7 @@ public class NetherPortalBlock extends Block {
                 }
             }
         }
-
+         */
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index 71df7c590e31932f2b8fc26a2afaaa54f52674ac..f7d6d908b96938a473d2b2da1f05bb213b72cd32 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -183,9 +183,11 @@ public class ChunkStatus {
         return ChunkStatus.lightChunk(chunkstatus, lightenginethreaded, ichunkaccess);
     });
     public static final ChunkStatus SPAWN = ChunkStatus.registerSimple("spawn", ChunkStatus.LIGHT, 0, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        /*
         if (!ichunkaccess.isUpgrading()) {
             chunkgenerator.spawnOriginalMobs(new WorldGenRegion(worldserver, list, chunkstatus, -1));
-        }
+        }t
+         */
 
     });
     public static final ChunkStatus HEIGHTMAPS = ChunkStatus.registerSimple("heightmaps", ChunkStatus.SPAWN, 0, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
@@ -372,9 +374,7 @@ public class ChunkStatus {
         default CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus targetStatus, Executor executor, ServerLevel world, ChunkGenerator generator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> fullChunkConverter, List<ChunkAccess> chunks, ChunkAccess chunk, boolean regenerate) {
             if (regenerate || !chunk.getStatus().isOrAfter(targetStatus)) {
                 this.doWork(targetStatus, world, generator, chunks, chunk);
-                if (chunk instanceof ProtoChunk) {
-                    ProtoChunk protochunk = (ProtoChunk) chunk;
-
+                if (chunk instanceof ProtoChunk protochunk) {
                     protochunk.setStatus(targetStatus);
                 }
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index de7a5f3812a017131fd1b32fbeff10e325b1cd2e..56cd8773ae92a30be1d284b45d10644bfcaf61cb 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -959,7 +959,7 @@ public class LevelChunk extends ChunkAccess {
         if (!this.loadedTicketLevel) { LOGGER.error("Double calling chunk unload!", new Throwable()); } // Paper
         org.bukkit.Server server = this.level.getCraftServer();
         this.chunkHolder.getEntityChunk().callEntitiesUnloadEvent(); // Paper - rewrite chunk system
-        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, true); // Paper - rewrite chunk system - force save to true so that mustNotSave is correctly set below
+        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, false); // Paper - rewrite chunk system - force save to true so that mustNotSave is correctly set below
         server.getPluginManager().callEvent(unloadEvent);
         // note: saving can be prevented, but not forced if no saving is actually required
         this.mustNotSave = !unloadEvent.isSaveChunk();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index 6b84633bf6956406d2e2c5dd32fa358f41ccc890..3cc577f742d5b7b02828fb857d9f7a5311cc8914 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -407,6 +407,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
     @Override
     public void spawnOriginalMobs(WorldGenRegion region) {
+        /*
         if (!((NoiseGeneratorSettings) this.settings.value()).disableMobGeneration()) {
             ChunkPos chunkcoordintpair = region.getCenter();
             Holder<Biome> holder = region.getBiome(chunkcoordintpair.getWorldPosition().atY(region.getMaxBuildHeight() - 1));
@@ -415,5 +416,6 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
             seededrandom.setDecorationSeed(region.getSeed(), chunkcoordintpair.getMinBlockX(), chunkcoordintpair.getMinBlockZ());
             NaturalSpawner.spawnMobsForChunkGeneration(region, holder, chunkcoordintpair, seededrandom);
         }
+         */
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index a9673a804d597599c35c83f4f245510c83005328..c1b288f249059c3dec3365c4fbcf8d376c0b74c8 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -313,6 +313,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 
     @Override
     public void spawnOriginalMobs(WorldGenRegion region) {
+        /*
         WorldgenRandom random = CustomChunkGenerator.getSeededRandom();
         int x = region.getCenter().x;
         int z = region.getCenter().z;
@@ -321,6 +322,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
         if (this.generator.shouldGenerateMobs(this.world.getWorld(), new RandomSourceWrapper.RandomWrapper(random), x, z)) {
             this.delegate.spawnOriginalMobs(region);
         }
+         */
     }
 
     @Override
